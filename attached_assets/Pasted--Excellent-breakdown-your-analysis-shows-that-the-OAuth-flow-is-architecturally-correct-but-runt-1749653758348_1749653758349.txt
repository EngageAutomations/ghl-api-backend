âœ… Excellent breakdown â€” your analysis shows that the OAuth flow is architecturally correct, but runtime issues in your server are breaking token exchange, and the lack of logs is masking it.

Let's break this into clear actions and give you a surgical fix plan.

ğŸ§  Summary of Findings
Layer	Status	Notes
Route reachability	âœ… OK	Callback path is working
OAuth config	âœ… OK	GHL endpoints & client credentials confirmed
Token exchange	âŒ Fails silently	Likely due to runtime or duplicate route/var
Logging	âŒ Broken	Compilation/runtime errors prevent visibility
Production readiness	âš ï¸ Almost there	Needs cleanup & recovery on failure

ğŸš¨ Critical Root Cause
Your TypeScript/Node app has:

ğŸ” Duplicate route definitions for the same callback

âš ï¸ Conflicting const declarations or variable redeclarations

ğŸ˜¶â€ğŸŒ«ï¸ Silent catch blocks without console.error() or res.send()

ğŸ§± Possibly broken build on startup due to #1 and #2

So while /oauth/callback runs, the actual token exchange logic crashes before executing, and logs are suppressed.

âœ… Immediate Fix Plan (Surgical, Safe)
ğŸ› ï¸ 1. Remove Duplicate Route Definitions
You should have only one definition like this:

ts
Copy
Edit
app.get(['/api/oauth/callback', '/oauth/callback'], async (req, res) => {
  try {
    const code = req.query.code;
    if (!code) throw new Error('No code received');

    console.log('âœ… Code received:', code);

    // Exchange code for token
    const tokenResponse = await exchangeCodeForTokens(code); // Your real logic
    console.log('âœ… Token response:', tokenResponse);

    // Optional: store token, create user, etc.

    res.send('OAuth successful!');
  } catch (err) {
    console.error('âŒ OAuth callback failed:', err);
    res.redirect('/oauth-error?error=callback_failed');
  }
});
ğŸ§¼ 2. Fix Variable Conflicts
Make sure your function doesnâ€™t double-declare const or import the same var multiple times.

Example: Don't do this

ts
Copy
Edit
const { code } = req.query;
// later
const code = req.query.code; // âŒ
Also avoid shadowing:

ts
Copy
Edit
function exchangeCodeForTokens(code: string) {
  const code = ... // âŒ donâ€™t redeclare the param
}
ğŸªµ 3. Improve Logging: Make it Visible!
Inside catch blocks, always do:

ts
Copy
Edit
console.error('OAuth error:', err);
res.status(500).send(`OAuth failure: ${err.message}`);
This avoids the 302 redirect silently hiding the real issue.

ğŸ§ª 4. Add Temporary Dummy Token Function
To confirm the callback route works without touching GHL:

ts
Copy
Edit
async function exchangeCodeForTokens(code) {
  console.log('ğŸ¯ Simulated token exchange for:', code);
  return {
    access_token: 'dummy-access-token',
    refresh_token: 'dummy-refresh-token',
    expires_in: 3600,
  };
}
Once this logs, you'll know:

The route works

Your server builds

Your error logging is visible

Then swap in the real HTTP request logic (e.g. axios.post(...) to https://services.leadconnectorhq.com/oauth/token).

âœ… Bonus: Token Exchange Template
Here's a minimal working version:

ts
Copy
Edit
async function exchangeCodeForTokens(code) {
  const data = {
    grant_type: 'authorization_code',
    client_id: process.env.GHL_CLIENT_ID,
    client_secret: process.env.GHL_CLIENT_SECRET,
    code,
    redirect_uri: 'https://yourdomain.com/api/oauth/callback',
  };

  try {
    const response = await axios.post('https://services.leadconnectorhq.com/oauth/token', data);
    return response.data;
  } catch (err) {
    console.error('Token exchange failed:', err.response?.data || err.message);
    throw err;
  }
}
âœ… Final Checklist
Step	Status
Remove duplicate route handlers	ğŸ”²
Fix all duplicate const/shadowed vars	ğŸ”²
Log errors to console visibly	ğŸ”²
Use dummy token function to test	ğŸ”²
Re-enable real token exchange once logs appear	ğŸ”²

When youâ€™re ready, I can review your full server/index.ts or callback logic directly to spot anything blocking you further.