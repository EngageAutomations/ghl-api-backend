# OAuth Dual-Domain Architecture Implementation Plan

This document outlines a step-by-step implementation of your dual-domain OAuth setup (Railway backend + Replit frontend + custom domain), and provides concrete answers to the critical questions you've identified.

---

## 1. Overview of Architecture

1. **GoHighLevel Marketplace** triggers installation →
2. **Railway OAuth Backend** at `https://dir.engageautomations.com` handles OAuth exchange →
3. **Custom Domain Frontend** at `https://listings.engageautomations.com` (Replit) manages UI & sessions →
4. **Universal API Router** on Railway forwards `/api/ghl/*` calls to GHL with injected tokens →
5. **Database** stores installations and tokens in PostgreSQL.

---

## 2. Detailed Implementation Steps

### 2.1 Railway OAuth Backend Setup

* **OAuth Flow**: Use Authorization Code with PKCE for maximum security.
* **Redirect URI**: `https://dir.engageautomations.com/api/oauth/callback`
* **Scopes**: products.write, contacts.write, locations.readonly, etc. (request all upfront; use incremental if user experience suffers).

```js
// railway-backend/index.js
app.get('/api/oauth/callback', async (req, res) => {
  const { code, state, locationId } = req.query;
  const tokenResponse = await fetch('https://services.leadconnectorhq.com/oauth/token', {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: new URLSearchParams({
      grant_type: 'authorization_code',
      code,
      redirect_uri: 'https://dir.engageautomations.com/api/oauth/callback',
      client_id: process.env.GHL_CLIENT_ID,
      client_secret: process.env.GHL_CLIENT_SECRET,
      code_verifier: state  // PKCE
    })
  });
  const tokens = await tokenResponse.json();

  // Store tokens
  await storage.createInstallation({
    ghlUserId: tokens.user_id,
    locationId,
    accessToken: tokens.access_token,
    refreshToken: tokens.refresh_token,
    expiresAt: new Date(Date.now() + tokens.expires_in * 1000),
    scopes: tokens.scope
  });

  // Redirect back to frontend
  res.redirect('https://listings.engageautomations.com/oauth-success?userId=' + tokens.user_id);
});
```

---

### 2.2 Database Schema for OAuth Installations

```sql
CREATE TABLE oauth_installations (
  id SERIAL PRIMARY KEY,
  ghl_user_id TEXT UNIQUE NOT NULL,
  location_id TEXT NOT NULL,
  access_token TEXT NOT NULL,
  refresh_token TEXT NOT NULL,
  expires_at TIMESTAMP NOT NULL,
  scopes TEXT NOT NULL,
  user_info JSONB,
  location_info JSONB,
  created_at TIMESTAMP DEFAULT NOW()
);
```

* **Encryption**: At-rest encryption handled by managed PostgreSQL; consider column-level encryption for tokens.

---

### 2.3 Universal API Router

* **Configuration-Driven**: Define all 50+ endpoints in `server/api-config.js`.
* **Dynamic Matching**: Extract path params, scope checks, and forward.

```ts
// server/index.ts
app.all('/api/ghl/*', async (req, res) => {
  const path = req.path.replace('/api/ghl', '');
  const config = findEndpointConfig(req.method, path);
  if (!config) return res.status(404).json({ error: 'Unknown endpoint' });

  const installation = await getInstallationFromSession(req);
  if (!installation) return res.status(401).json({ error: 'Not authenticated' });

  // Optionally refresh token if expired
  if (new Date() > installation.expiresAt) {
    await refreshTokens(installation);
  }

  const url = buildGHLEndpoint(config, extractPathParams(config.pattern, path), installation.location_id);
  const forwardRes = await fetch(url, {
    method: req.method,
    headers: {
      'Authorization': `Bearer ${installation.access_token}`,
      'Content-Type': 'application/json',
      'Version': '2021-07-28'
    },
    body: req.method !== 'GET' ? JSON.stringify(req.body) : undefined
  });
  const data = await forwardRes.json();
  res.status(forwardRes.status).json(data);
});
```

---

### 2.4 Custom Domain Frontend (Replit) & Session Recovery

```tsx
// client/src/pages/OAuthSuccess.tsx
useEffect(() => {
  const params = new URLSearchParams(window.location.search);
  const userId = params.get('userId');
  if (userId) {
    fetch('/api/auth/recover', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ ghlUserId: userId })
    });
  }
}, []);
```

```js
// railway-backend/auth.js
app.post('/api/auth/recover', async (req, res) => {
  const { ghlUserId, locationId } = req.body;
  const installation = await storage.find({ ghlUserId, locationId });
  if (!installation) return res.sendStatus(401);

  const token = jwt.sign({ installationId: installation.id }, process.env.JWT_SECRET);
  res.cookie('session_token', token, { httpOnly: true, secure: true, sameSite: 'none' });
  res.sendStatus(200);
});
```

---

### 2.5 Token Refresh Strategy

* **When**: Check `expires_at` before each request in the router; if expired, call `/oauth/token?grant_type=refresh_token`.
* **Where**: All refresh logic lives in a helper (`refreshTokens(installation)`).
* **Storage**: Update `access_token`, `refresh_token`, and `expires_at` in DB.

---

## 3. Answers to Key Questions

1. **Which OAuth flow?** Use *Authorization Code* with PKCE for strong security and compatibility with SPAs.
2. **Scope strategy?** Request all required scopes upfront. If you add features later, implement incremental authorization to minimize user prompts.
3. **Token storage?** Persist in PostgreSQL with at-rest DB encryption; consider AES encryption at the application layer for tokens.
4. **Multi-tenant?** Tie each installation to `ghl_user_id` + `location_id`. Allow multiple installations per user by making `(ghl_user_id, location_id)` unique, not `ghl_user_id` alone.
5. **Universal router?** Single Express endpoint `/api/ghl/*`, config-driven dispatch, dynamic path-param extraction.
6. **Error handling?** Retry on 401 (once), circuit-break on repeated 5xx, backoff on 429 with `Retry-After`.
7. **Rate limiting?** Implement token-based buckets in Redis; queue requests when limit is near.
8. **CSRF protection?** Use state parameter and verify on callback; enforce secure, sameSite cookies.
9. **Monitoring?** Track metrics: *oauth.token\_exchanges*, *api.requests\_per\_endpoint*, *refresh\_failures* via Prometheus/Grafana.
10. **Testing?** Use mocked OAuth server in dev; write integration tests with *nock* to simulate token refresh and API errors.

---

## 4. Next Steps

* **Frontend**: Add `useMutation` hooks for edit & delete; wire to buttons.
* **Bulk ops**: Extend router to accept arrays, batch in parallel.
* **Real-time updates**: Integrate WebSockets or Server-Sent Events for live data.
* **Documentation**: Publish API-config spec and internal OAuth flow docs.

*Feel free to review each section, let me know where you'd like more detail or code samples!*
