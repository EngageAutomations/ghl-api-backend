Thank you for the detailed issue report ‚Äî this is a **very common UI challenge** when combining toggle switches with collapsible accordions, especially when trying to enforce **mutual exclusivity** *without triggering accordion toggles* unintentionally.

Here's a precise breakdown of how to resolve each of the issues you're facing, based on your current setup and goals:

---

## ‚úÖ Issue 1: **Toggle Click Still Expands Accordion**

### üîç Problem:

Even though `stopPropagation()` is used, the toggle is likely still inside or too close to the `AccordionTrigger`, so the event bubbles up before it‚Äôs intercepted.

### ‚úÖ Solution:

**Move the toggle completely outside the `AccordionTrigger`**, and instead place it:

* In the header **but outside the click boundary** of the `AccordionTrigger`
* Or absolutely position it in the header area so it‚Äôs visually together, but functionally independent

### üîß Example Fix:

```tsx
<AccordionItem value="action">
  <div className="flex justify-between items-center">
    <AccordionTrigger>Action Button Opt-In</AccordionTrigger>

    {/* Toggle is visually in the header, but NOT inside AccordionTrigger */}
    <div onClick={(e) => { e.stopPropagation(); toggleAction(); }}>
      <CustomSwitch checked={isActionEnabled} />
    </div>
  </div>
  <AccordionContent>
    {/* Action config content */}
  </AccordionContent>
</AccordionItem>
```

---

## ‚úÖ Issue 2: **Both Toggles Can Be Active**

### üîç Problem:

State updates are async in React, and without guarding for simultaneous state flips, both can momentarily become `true`.

### ‚úÖ Solution:

Use a **single source of truth** state that explicitly defines the selected option (`'action' | 'embed' | null`) instead of separate booleans.

### üîß Replace this:

```tsx
const [isActionEnabled, setActionEnabled] = useState(false);
const [isEmbedEnabled, setEmbedEnabled] = useState(false);
```

### ‚úÖ With this:

```tsx
const [selectedOptIn, setSelectedOptIn] = useState<'action' | 'embed' | null>(null);

// Usage
const isActionEnabled = selectedOptIn === 'action';
const isEmbedEnabled = selectedOptIn === 'embed';

function toggleAction() {
  setSelectedOptIn(prev => prev === 'action' ? null : 'action');
}

function toggleEmbed() {
  setSelectedOptIn(prev => prev === 'embed' ? null : 'embed');
}
```

This **guarantees mutual exclusivity** and eliminates `useEffect` syncing entirely.

---

## ‚úÖ Issue 3: **Smooth Toggle Animations + Positioning**

Since you‚Äôre already using a custom `CustomSwitch`, just ensure:

* You apply CSS transitions on the `transform`, `left`, or `box-shadow` properties
* Use `pointer-events: none` on visual container overlays to prevent clicks interfering with position containers

---

## üß© Summary of What to Change

| Problem                        | Solution                                                                                              |         |         |
| ------------------------------ | ----------------------------------------------------------------------------------------------------- | ------- | ------- |
| Toggle click expands accordion | Move toggle *outside* the `AccordionTrigger`, or use `e.stopPropagation()` outside the trigger zone   |         |         |
| Both toggles active            | Replace dual-booleans with a **single state enum** (\`'action'                                        | 'embed' | null\`) |
| Toggle feels misaligned        | Ensure it's absolutely/flex positioned in header; use `z-index` and margin rules for layout stability |         |         |
| Prevent event leakage          | Use `e.stopPropagation()` and `pointer-events: none` on wrapper if needed                             |         |         |

---

Would you like me to refactor this into a working React component scaffold for you to copy into Replit?
