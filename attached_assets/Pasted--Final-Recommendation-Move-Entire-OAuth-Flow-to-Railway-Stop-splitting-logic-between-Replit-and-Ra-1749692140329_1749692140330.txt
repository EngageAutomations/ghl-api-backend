✅ Final Recommendation: Move Entire OAuth Flow to Railway
Stop splitting logic between Replit and Railway.
Instead, handle the entire OAuth flow — including token exchange — inside the Railway backend.

You can still serve your frontend (Replit or elsewhere) and have it communicate with Railway’s /api endpoints via fetch.

🔁 Why Your Current Setup Fails
Layer	Problem
🚨 Railway	Only receives the code — but just redirects it instead of exchanging it for a token.
🚨 Replit	Can’t handle OAuth callbacks properly in production due to static routing.
🚫 Shared Callback	Creates a loop: GoHighLevel → Railway → Replit → nowhere.
🔁 Result	Token exchange never happens. Authorization codes expire unused.

✅ Working Architecture Blueprint
🎯 Goal: Make Railway the OAuth brain, and use Replit only for UI/frontend.

Updated Flow:
User installs your app on GoHighLevel

They are redirected to:

ruby
Copy
Edit
https://oauth-backend.up.railway.app/api/oauth/callback?code=...
Railway handles:

Code exchange

Token storage

User creation

Final redirect back to your frontend:

arduino
Copy
Edit
res.redirect("https://dir.engageautomations.com/oauth-success");
🧱 Railway Code Template (Fix)
Here’s a fully working index.ts that doesn’t redirect back with the code — instead, it completes the flow internally.

ts
Copy
Edit
import express from 'express';
import axios from 'axios';
import cookieParser from 'cookie-parser';
import dotenv from 'dotenv';
dotenv.config();

const app = express();
app.use(express.json());
app.use(cookieParser());

const PORT = process.env.PORT || 5000;

app.get('/api/oauth/callback', async (req, res) => {
  const { code, state, error } = req.query;

  if (error) {
    return res.redirect(`https://dir.engageautomations.com/oauth-error?error=${error}`);
  }

  if (!code) {
    return res.status(400).send('Missing authorization code');
  }

  try {
    const response = await axios.post('https://services.leadconnectorhq.com/oauth/token', {
      grant_type: 'authorization_code',
      client_id: process.env.GHL_CLIENT_ID,
      client_secret: process.env.GHL_CLIENT_SECRET,
      code,
      redirect_uri: process.env.GHL_REDIRECT_URI,
    });

    const { access_token, refresh_token, expires_in } = response.data;

    // Store token in database here (or return to frontend)
    console.log("✅ Token exchange successful", response.data);

    // Redirect to your frontend
    return res.redirect(`https://dir.engageautomations.com/oauth-success`);
  } catch (err: any) {
    console.error("❌ Token exchange failed", err.response?.data || err.message);
    return res.redirect(`https://dir.engageautomations.com/oauth-error?error=token_failed`);
  }
});

app.listen(PORT, () => {
  console.log(`✅ OAuth backend running on port ${PORT}`);
});
📦 Required .env Variables on Railway
Key	Example
GHL_CLIENT_ID	Your GoHighLevel App ID
GHL_CLIENT_SECRET	Your App Secret
GHL_REDIRECT_URI	https://oauth-backend.up.railway.app/api/oauth/callback

🌐 Update GoHighLevel Redirect URI
In your GoHighLevel Marketplace Developer settings:

Set redirect URI to:

ruby
Copy
Edit
https://oauth-backend.up.railway.app/api/oauth/callback
🟢 Frontend Flow (Replit stays simple)
In Replit:

Start OAuth from /api/oauth/start (or construct URL directly)

Redirect user to GoHighLevel

When OAuth succeeds, they'll land on:

arduino
Copy
Edit
https://dir.engageautomations.com/oauth-success
Use that route to show a success screen, store tokens via fetch('/api/save-tokens'), etc.

🧼 Final Cleanup Tasks
Task	Status
🔥 Remove redirect in Railway callback	✅ Done
✅ Handle token exchange inside Railway	✅ Done
❌ Stop passing code back to Replit	✅ Removed
🧹 Clear Replit /api/oauth/callback	✅ No longer used
🔁 Proxy API calls (optional)	use Replit → Railway proxy for /api/*

✅ You Are Now Fully 