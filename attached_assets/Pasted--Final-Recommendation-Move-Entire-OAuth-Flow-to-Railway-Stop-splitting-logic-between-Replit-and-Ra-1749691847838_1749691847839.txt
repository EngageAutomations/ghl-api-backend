âœ… Final Recommendation: Move Entire OAuth Flow to Railway
Stop splitting logic between Replit and Railway.
Instead, handle the entire OAuth flow â€” including token exchange â€” inside the Railway backend.

You can still serve your frontend (Replit or elsewhere) and have it communicate with Railwayâ€™s /api endpoints via fetch.

ğŸ” Why Your Current Setup Fails
Layer	Problem
ğŸš¨ Railway	Only receives the code â€” but just redirects it instead of exchanging it for a token.
ğŸš¨ Replit	Canâ€™t handle OAuth callbacks properly in production due to static routing.
ğŸš« Shared Callback	Creates a loop: GoHighLevel â†’ Railway â†’ Replit â†’ nowhere.
ğŸ” Result	Token exchange never happens. Authorization codes expire unused.

âœ… Working Architecture Blueprint
ğŸ¯ Goal: Make Railway the OAuth brain, and use Replit only for UI/frontend.

Updated Flow:
User installs your app on GoHighLevel

They are redirected to:

ruby
Copy
Edit
https://oauth-backend.up.railway.app/api/oauth/callback?code=...
Railway handles:

Code exchange

Token storage

User creation

Final redirect back to your frontend:

arduino
Copy
Edit
res.redirect("https://dir.engageautomations.com/oauth-success");
ğŸ§± Railway Code Template (Fix)
Hereâ€™s a fully working index.ts that doesnâ€™t redirect back with the code â€” instead, it completes the flow internally.

ts
Copy
Edit
import express from 'express';
import axios from 'axios';
import cookieParser from 'cookie-parser';
import dotenv from 'dotenv';
dotenv.config();

const app = express();
app.use(express.json());
app.use(cookieParser());

const PORT = process.env.PORT || 5000;

app.get('/api/oauth/callback', async (req, res) => {
  const { code, state, error } = req.query;

  if (error) {
    return res.redirect(`https://dir.engageautomations.com/oauth-error?error=${error}`);
  }

  if (!code) {
    return res.status(400).send('Missing authorization code');
  }

  try {
    const response = await axios.post('https://services.leadconnectorhq.com/oauth/token', {
      grant_type: 'authorization_code',
      client_id: process.env.GHL_CLIENT_ID,
      client_secret: process.env.GHL_CLIENT_SECRET,
      code,
      redirect_uri: process.env.GHL_REDIRECT_URI,
    });

    const { access_token, refresh_token, expires_in } = response.data;

    // Store token in database here (or return to frontend)
    console.log("âœ… Token exchange successful", response.data);

    // Redirect to your frontend
    return res.redirect(`https://dir.engageautomations.com/oauth-success`);
  } catch (err: any) {
    console.error("âŒ Token exchange failed", err.response?.data || err.message);
    return res.redirect(`https://dir.engageautomations.com/oauth-error?error=token_failed`);
  }
});

app.listen(PORT, () => {
  console.log(`âœ… OAuth backend running on port ${PORT}`);
});
ğŸ“¦ Required .env Variables on Railway
Key	Example
GHL_CLIENT_ID	Your GoHighLevel App ID
GHL_CLIENT_SECRET	Your App Secret
GHL_REDIRECT_URI	https://oauth-backend.up.railway.app/api/oauth/callback

ğŸŒ Update GoHighLevel Redirect URI
In your GoHighLevel Marketplace Developer settings:

Set redirect URI to:

ruby
Copy
Edit
https://oauth-backend.up.railway.app/api/oauth/callback
ğŸŸ¢ Frontend Flow (Replit stays simple)
In Replit:

Start OAuth from /api/oauth/start (or construct URL directly)

Redirect user to GoHighLevel

When OAuth succeeds, they'll land on:

arduino
Copy
Edit
https://dir.engageautomations.com/oauth-success
Use that route to show a success screen, store tokens via fetch('/api/save-tokens'), etc.

ğŸ§¼ Final Cleanup Tasks
Task	Status
ğŸ”¥ Remove redirect in Railway callback	âœ… Done
âœ… Handle token exchange inside Railway	âœ… Done
âŒ Stop passing code back to Replit	âœ… Removed
ğŸ§¹ Clear Replit /api/oauth/callback	âœ… No longer used
ğŸ” Proxy API calls (optional)	use Replit â†’ Railway proxy for /api/*

âœ… You Are Now Fully 